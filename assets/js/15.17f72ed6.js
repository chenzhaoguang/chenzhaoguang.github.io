(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{485:function(e,r,t){"use strict";t.r(r);var n=t(2),o=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[e._v("前言")]),e._v(" "),t("p",[e._v("你知道C#的前世是什么样的吗？你又知道它在这些年的衍变进化是怎样的吗？")]),e._v(" "),t("h2",{attrs:{id:"c-version-1-0"}},[e._v("C# version 1.0")]),e._v(" "),t("p",[e._v("回首看去，你会发现C# 1.0与java是非常相似的。作为"),t("a",{attrs:{href:"http://feeldotneteasy.blogspot.com/2011/01/c-design-goals.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECMA规定的一部分"),t("OutboundLink")],1),e._v("，它试图成为一门“简单、现代化、面向对象的一门语言”。在那个时候，与java相似，意味着它已经达到了早期目标。")]),e._v(" "),t("p",[e._v("不过从现在的角度来看，1.0的语法是有点傻的。它既缺乏对异步操作的支持，也没有泛型，至于LINQ？更是几年以后的事情了。")]),e._v(" "),t("p",[e._v("对比现在来说，1.0是几乎没有什么特性的，以至于在当时不得不写很多累赘的代码。它给我们多了一个选择，在windows上我们可以用它来替代Java。")]),e._v(" "),t("h2",{attrs:{id:"c-version-2-0"}},[e._v("C# version 2.0")]),e._v(" "),t("p",[e._v("C# 2.0是在2005年随着 Visual Studio 2005一起发布的，从这个版本开始，它才开始变得更有意思。让我们来看看 2.0的主要特性：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/index",target:"_blank",rel:"noopener noreferrer"}},[e._v("泛型"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods#partial-classes",target:"_blank",rel:"noopener noreferrer"}},[e._v("分部类"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-methods",target:"_blank",rel:"noopener noreferrer"}},[e._v("匿名函数"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/index",target:"_blank",rel:"noopener noreferrer"}},[e._v("可空类型"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/iterators",target:"_blank",rel:"noopener noreferrer"}},[e._v("迭代器"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/index",target:"_blank",rel:"noopener noreferrer"}},[e._v("协变和逆变"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("C# 2.0的改变非常迅速，也非常重大，实实在在的解决了开发者实际中碰到到的很多问题。")]),e._v(" "),t("p",[e._v("通过泛型，你可以自由给数据指定任意类型，并且编译器层次就保证了数据安全和一致性。比方说，你使用List<string>或List<int>的时候，它就保证了你遍历出来的数据一定是string或int。这比定义一个新类型ListInt或者从Object类型转换要好的多。毕竟定义新类型太麻烦，而从object转化又会导致性能损失。")]),e._v(" "),t("p",[e._v("C# 2.0还引入了迭代器。简单来说，你可以通过foreach来遍历一个List（或者其他实现了IEnumerable的可枚举类型）。这个特性极大的提高了代码的可读性和可理解性。")]),e._v(" "),t("p",[e._v("不过，到目前为止仍然还只是在追赶java而已。泛型和迭代器在Java中已经被实现了。但是随着C#的不断进化，这种情况很快就改善了。")]),e._v(" "),t("h2",{attrs:{id:"c-version-3-0"}},[e._v("C# version 3.0")]),e._v(" "),t("p",[e._v("C# 3.0是在2007年随着Visual Studio 2008一起发布的，不过语言特性实际上大多是在C# 3.5中发布的。这个版本带来了非常大的提升，把C#变成了一门真正强大的语言。让我们来看看这个版本的主要特性：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties",target:"_blank",rel:"noopener noreferrer"}},[e._v("自动属性"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/anonymous-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("匿名类"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/linq/query-expression-basics",target:"_blank",rel:"noopener noreferrer"}},[e._v("查询表达式"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.daedtech.com/introduction-to-c-lambda-expressions/",target:"_blank",rel:"noopener noreferrer"}},[e._v("拉姆达表达式"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://blogs.msdn.microsoft.com/charlie/2008/01/31/expression-tree-basics/",target:"_blank",rel:"noopener noreferrer"}},[e._v("表达式树"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.codeproject.com/Tips/709310/Extension-Method-In-Csharp",target:"_blank",rel:"noopener noreferrer"}},[e._v("扩展方法"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("回想起来，这里的许多特性都是必然而且无法分割的。他们在战略上来说都是结合在一起的。一般都认为这个版本的杀手级特性是查询表达式，也称之为语言集成查询（Language-Integrated Query：LINQ）。")]),e._v(" "),t("p",[e._v("另一角度来说，表达式树、拉姆达表达式和匿名类都是构建LINQ的基石。不管从哪个角度来说，C#3.0都是提供了一个革命性的概念。C#3.0已经开始为将C#转变成为混合面向对象/函数语言打下了基础。")]),e._v(" "),t("p",[e._v("具体来说，你现在可以像写sql那样来查询、操作集合了。可以直接用list.Average()来求和，而不用自己手动循环遍历数组来求和了。")]),e._v(" "),t("p",[e._v("这个概念需要时间来真正掌握，基于linq我们能写出能更简洁、实用的代码。")]),e._v(" "),t("h2",{attrs:{id:"c-version-4-0"}},[e._v("C# version 4.0")]),e._v(" "),t("p",[e._v("3.0开始，C#已经从Java的阴影中走出并凸显出来，这门语言正在迅速变得更优雅。")]),e._v(" "),t("p",[e._v("4.0版本主要新增了以下特性：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic",target:"_blank",rel:"noopener noreferrer"}},[e._v("dynamic 动态绑定"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments",target:"_blank",rel:"noopener noreferrer"}},[e._v("命名/可空参数"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance",target:"_blank",rel:"noopener noreferrer"}},[e._v("泛型的协变/逆变"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://stackoverflow.com/questions/20514240/whats-the-difference-setting-embed-interop-types-true-and-false-in-visual-studi",target:"_blank",rel:"noopener noreferrer"}},[e._v("嵌入组件交互类型"),t("OutboundLink")],1)])]),e._v(" "),t("blockquote",[t("p",[e._v("开发com组件和vsx扩展程序时，一般都需要引入其他的PIA（Primary Interop Assemblies），这个选项指示是否把引用的PIA打包到项目dll中（也就是是否打包依赖）。在开发vsx之类的扩展程序时设置为false，因为vsx的依赖PIA在操作系统中都会是内置的。"),t("em",[e._v("（好吧，COM组件已经是过去时了，个人感觉这个特性没啥意义了）")])])]),e._v(" "),t("p",[e._v("嵌入组件交互类型减轻了部署的痛苦。泛型的协变/逆变让泛型变得更强大，不过这个特性可能主要是被框架、类库作者所使用。命名和可空参数可以免去许多方法重载，写起来更遍历。但这些都不是主要的特性。")]),e._v(" "),t("p",[e._v('主要的特性是新增的dynamic关键字。通过dynamic可以像javascript那样创建动态结构。比如你可以创建一个 dynamic x="a string"，然后给他加上6，runtime会自动判定类型并计算结果。')]),e._v(" "),t("p",[e._v("dynamic可能会导致潜在的错误，但也让你拥有更大的自由度和能力了。")]),e._v(" "),t("h2",{attrs:{id:"c-version-5-0"}},[e._v("C# version 5.0")]),e._v(" "),t("p",[e._v("5.0也同样有着巨大的改变，几乎每一个都是开创性的。以下为主要新增特性：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://docs.microsoft.com/en-us/dotnet/csharp/async",target:"_blank",rel:"noopener noreferrer"}},[e._v("async await 异步操作"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.codeproject.com/Tips/606379/Caller-Info-Attributes-in-Csharp",target:"_blank",rel:"noopener noreferrer"}},[e._v("调用者属性"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("调用者属性让你可以非常容易地得知调用当前方法的上下文，比如调用当前方法的方法名是什么、在哪个文件、第几行等等。这个在日志和诊断中非常有用。")]),e._v(" "),t("p",[e._v("不过async和await才是这个版本的真正明星。这个特性是在2012年出来的，从此异步操作也成为了C#的一等公民。如果你曾经处理过长耗时任务和网络回调的实现，相信你会喜欢上这个特性的。")]),e._v(" "),t("h2",{attrs:{id:"c-version6-0"}},[e._v("C# version6.0")]),e._v(" "),t("p",[e._v("通过3.0和5.0的两次更新，C#作为一门面向对象语言，已经提供了非常亮眼的特性。在6.0中，没有发布开创性的语言特性，而是改为完善语法糖，让C#用起来更为简洁、舒服。以下是主要特性：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:""}},[e._v("静态导入")])]),e._v(" "),t("li",[t("a",{attrs:{href:""}},[e._v("异常过滤")])])])])}),[],!1,null,null,null);r.default=o.exports}}]);